<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>pyaurorax.tools.classes.keogram API documentation</title>
<meta name="description" content="Class representation for a keogram.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
<style>
@media screen and (max-width: 699px) {
#content {
padding-left: 2em;
padding-right: 2em;
padding-top: 0;
}
}
@media screen and (min-width: 700px) {
#content {
max-width: 125ch;
padding-left: 3em;
padding-right: 3em;
padding-top: 1em;
border-left: 1px solid #ddd;
}
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyaurorax.tools.classes.keogram</code></h1>
</header>
<section id="section-intro">
<p>Class representation for a keogram.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyaurorax.tools.classes.keogram.Keogram"><code class="flex name class">
<span>class <span class="ident">Keogram</span></span>
<span>(</span><span>data: numpy.ndarray,<br>timestamp: List[datetime.datetime],<br>instrument_type: str,<br>slice_idx: int | None = None,<br>ccd_y: numpy.ndarray | None = None,<br>mag_y: numpy.ndarray | None = None,<br>geo_y: numpy.ndarray | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Keogram:
    &#34;&#34;&#34;
    Class representation for a keogram

    Attributes:
        data (numpy.ndarray): 
            The derived keogram data.

        timestamp (List[datetime.datetime]): 
            Timestamps corresponding to each keogram slice.

        instrument_type (str): 
            String giving instrument type, either &#39;asi&#39; or &#39;spectrograph&#39;.

        ccd_y (numpy.ndarray): 
            The y-axis representing CCD Y coordinates for the keogram.

        mag_y (numpy.ndarray): 
            The y-axis representing magnetic latitude for the keogram.

        geo_y (numpy.ndarray): 
            The y-axis representing geographic latitude for the keogram.
    &#34;&#34;&#34;

    def __init__(self,
                 data: np.ndarray,
                 timestamp: List[datetime.datetime],
                 instrument_type: str,
                 slice_idx: Optional[int] = None,
                 ccd_y: Optional[np.ndarray] = None,
                 mag_y: Optional[np.ndarray] = None,
                 geo_y: Optional[np.ndarray] = None):
        # public vars
        self.data = data
        self.timestamp = timestamp
        self.instrument_type = instrument_type
        self.ccd_y = ccd_y
        self.mag_y = mag_y
        self.geo_y = geo_y

        # private vars
        self.__slice_idx = slice_idx

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        data_str = &#34;array(dims=%s, dtype=%s)&#34; % (self.data.shape, self.data.dtype)
        timestamp_str = &#34;[%d datetime objects]&#34; % (len(self.timestamp))
        ccd_y_str = &#34;None&#34; if self.ccd_y is None else &#34;array(%d values)&#34; % (self.ccd_y.shape[0])
        mag_y_str = &#34;None&#34; if self.mag_y is None else &#34;array(%d values)&#34; % (self.mag_y.shape[0])
        geo_y_str = &#34;None&#34; if self.geo_y is None else &#34;array(%d values)&#34; % (self.geo_y.shape[0])

        return &#34;Keogram(data=%s, timestamp=%s, ccd_y=%s, mag_y=%s, geo_y=%s)&#34; % (data_str, timestamp_str, ccd_y_str, mag_y_str, geo_y_str)

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        # set special strings
        data_str = &#34;array(dims=%s, dtype=%s)&#34; % (self.data.shape, self.data.dtype)
        timestamp_str = &#34;[%d datetime objects]&#34; % (len(self.timestamp))
        ccd_y_str = &#34;None&#34; if self.ccd_y is None else &#34;array(%d values)&#34; % (self.ccd_y.shape[0])
        mag_y_str = &#34;None&#34; if self.mag_y is None else &#34;array(%d values)&#34; % (self.mag_y.shape[0])
        geo_y_str = &#34;None&#34; if self.geo_y is None else &#34;array(%d values)&#34; % (self.geo_y.shape[0])

        # print
        print(&#34;Keogram:&#34;)
        print(&#34;  %-17s: %s&#34; % (&#34;data&#34;, data_str))
        print(&#34;  %-17s: %s&#34; % (&#34;timestamp&#34;, timestamp_str))
        print(&#34;  %-17s: %s&#34; % (&#34;instrument_type&#34;, self.instrument_type))
        print(&#34;  %-17s: %s&#34; % (&#34;ccd_y&#34;, ccd_y_str))
        print(&#34;  %-17s: %s&#34; % (&#34;geo_y&#34;, geo_y_str))
        print(&#34;  %-17s: %s&#34; % (&#34;mag_y&#34;, mag_y_str))

    def set_geographic_latitudes(self, skymap: Skymap, altitude_km: Optional[Union[int, float]] = None) -&gt; None:
        &#34;&#34;&#34;
        Set the geographic latitude values for this keogram, using the specified skymap 
        data. The data will be set to the geo_y attribute of this Keogram object, which
        can then be used for plotting and/or further analysis.

        Args:
            skymap (pyaurorax.data.ucalgary.Skymap): 
                The skymap object to use. This parameter is required.

            altitude_km (int): 
                The altitude to use, in kilometers. If not specified, it will use the default in the 
                skymap object. If the specified altitude is not valid, a ValueError will be raised.
        
        Returns:
            None. The Keogram object&#39;s `geo_y` attribute will be updated.

        Raises:
            ValueError: Issues with specified altitude.
        &#34;&#34;&#34;
        # check for slice idx
        if (self.__slice_idx is None):

            raise ValueError(&#34;Unable to set the geographic latitudes since the private slice_idx is None. If this keogram &#34; +
                             &#34;object was created as part of the custom_keogram routines or is a spectrogaph keogram, &#34; +
                             &#34;this is expected and performing this action is not supported at this time.&#34;)

        # Check the dimensions of the skymap lat/lon arrays
        # If they are 2-dimensional [altitude_idx, y] instead of [altitude_idx, y, x] then we know it is a spectrograph
        # skymap. In this case, we will simply reform to add an additional dimension, so that self.__slice_idx (which is
        # always zero for spectrograph data as there is only one longitudinal bin) can be used to index into the array
        # the same as it would be for ASI data
        if len(skymap.full_map_latitude.shape) == 2:
            # Reform all spectrograph skymap arrays to have an extra dimension, for indexing purposes
            skymap.full_map_latitude = skymap.full_map_latitude[:, :, np.newaxis]
            skymap.full_map_longitude = skymap.full_map_longitude[:, :, np.newaxis]
            skymap.full_elevation = skymap.full_elevation[:, np.newaxis]

        # determine altitude index to use
        if (altitude_km is not None):
            # Obtain lat/lon arrays from skymap
            if (altitude_km * 1000.0 in skymap.full_map_altitude):
                altitude_idx = np.where(altitude_km * 1000.0 == skymap.full_map_altitude)

                if skymap.full_map_latitude.shape[-1] == 1:
                    self.geo_y = np.squeeze(skymap.full_map_latitude[altitude_idx, :, 0]).copy()
                else:
                    self.geo_y = np.squeeze(skymap.full_map_latitude[altitude_idx, :, self.__slice_idx]).copy()
            else:
                # Make sure altitude is in range that can be interpolated
                if (altitude_km * 1000.0 &lt; skymap.full_map_altitude[0]) or (altitude_km * 1000.0 &gt; skymap.full_map_altitude[2]):
                    raise ValueError(&#34;Altitude &#34; + str(altitude_km) + &#34; outside valid range of &#34; +
                                     str((skymap.full_map_altitude[0] / 1000.0, skymap.full_map_altitude[2] / 1000.0)))

                # Initialze empty lat/lon arrays
                lats = np.full(np.squeeze(skymap.full_map_latitude[0, :, :]).shape, np.nan, dtype=skymap.full_map_latitude[0, :, :].dtype)

                # Interpolate lats and lons at desired altitude
                for i in range(skymap.full_map_latitude.shape[1]):
                    for j in range(skymap.full_map_latitude.shape[2]):
                        lats[i, j] = np.interp(altitude_km * 1000.0, skymap.full_map_altitude, skymap.full_map_latitude[:, i, j])

                self.geo_y = lats[:, self.__slice_idx].copy()
        else:
            # use default middle altitude
            if skymap.full_map_latitude.shape[-1] == 1:
                self.geo_y = np.squeeze(skymap.full_map_latitude[1, :, 0]).copy()
            else:
                self.geo_y = np.squeeze(skymap.full_map_latitude[1, :, self.__slice_idx]).copy()

    def set_magnetic_latitudes(self, skymap: Skymap, timestamp: datetime.datetime, altitude_km: Optional[Union[int, float]] = None) -&gt; None:
        &#34;&#34;&#34;
        Set the magnetic latitude values for this keogram, using the specified skymap 
        data. AACGMv2 will be utilized to perform the calculations. The resulting data
        will be set to the mag_y attribute of this Keogram object, which can then be
        used for plotting and/or further analysis.

        Args:
            skymap (pyaurorax.data.ucalgary.Skymap): 
                The skymap object to use. This parameter is required.

            timestamp (datetime.datetime): 
                The timestamp to use when converting skymap data to magnetic coordinates. Utilizes
                AACGMv2 to do the conversion.

            altitude_km (int): 
                The altitude to use. If not specified, it will use the default in the skymap
                object. If the specified altitude is not valid, a ValueError will be raised.
        
        Returns:
            None. The Keogram object&#39;s `mag_y` attribute will be updated.

        Raises:
            ValueError: Issues with specified altitude.
        &#34;&#34;&#34;

        # check for slice idx
        if (self.__slice_idx is None):
            raise ValueError(&#34;Unable to set the magnetic latitudes since the slice_idx is None. If this keogram &#34; +
                             &#34;object was created as part of the custom_keogram routines or is a spectrogaph keogram, &#34; +
                             &#34;this is expected and performing this action is not supported at this time.&#34;)

        # Check the dimensions of the skymap lat/lon arrays
        # If they are 2-dimensional [altitude_idx, y] instead of [altitude_idx, y, x] then we know it is a spectrograph
        # skymap. In this case, we will simply reform to add an additional dimension, so that self.__slice_idx (which is
        # always zero for spectrograph data as there is only one longitudinal bin) can be used to index into the array
        # the same as it would be for ASI data
        if len(skymap.full_map_latitude.shape) == 2:
            # Reform all spectrograph skymap arrays to have an extra dimension, for indexing purposes
            skymap.full_map_latitude = skymap.full_map_latitude[:, :, np.newaxis]
            skymap.full_map_longitude = skymap.full_map_longitude[:, :, np.newaxis]
            skymap.full_elevation = skymap.full_elevation[:, np.newaxis]

        # determine altitude index to use
        if (altitude_km is not None):
            # Obtain lat/lon arrays from skymap
            if (altitude_km * 1000.0 in skymap.full_map_altitude):
                altitude_idx = np.where(altitude_km * 1000.0 == skymap.full_map_altitude)

                lats = np.squeeze(skymap.full_map_latitude[altitude_idx, :, :])
                lons = np.squeeze(skymap.full_map_longitude[altitude_idx, :, :])
                lons[np.where(lons &gt; 180)] -= 360.0

            else:
                # Make sure altitude is in range that can be interpolated
                if (altitude_km * 1000.0 &lt; skymap.full_map_altitude[0]) or (altitude_km * 1000.0 &gt; skymap.full_map_altitude[2]):
                    raise ValueError(&#34;Altitude &#34; + str(altitude_km) + &#34; outside valid range of &#34; +
                                     str((skymap.full_map_altitude[0] / 1000.0, skymap.full_map_altitude[2] / 1000.0)))

                # Initialze empty lat/lon arrays
                lats = np.full(np.squeeze(skymap.full_map_latitude[0, :, :]).shape, np.nan, dtype=skymap.full_map_latitude[0, :, :].dtype)
                lons = lats.copy()

                # Interpolate lats and lons at desired altitude
                for i in range(skymap.full_map_latitude.shape[1]):
                    for j in range(skymap.full_map_latitude.shape[2]):
                        lats[i, j] = np.interp(altitude_km * 1000.0, skymap.full_map_altitude, skymap.full_map_latitude[:, i, j])
                        lons[i, j] = np.interp(altitude_km * 1000.0, skymap.full_map_altitude, skymap.full_map_longitude[:, i, j])

                lons[np.where(lons &gt; 180)] -= 360.0

            # Convert lats and lons to geomagnetic coordinates
            mag_lats, mag_lons, _ = aacgmv2.convert_latlon_arr(lats.flatten(), lons.flatten(), (lons * 0.0).flatten(), timestamp, method_code=&#39;G2A&#39;)
            mag_lats = np.reshape(mag_lats, lats.shape)
            mag_lons = np.reshape(mag_lons, lons.shape)

            # If lat/lon arrays are 1-dimensional then we know it is a spectrograph skymap. In this case, we will simply
            # reform to add an additional dimension, so that self.__slice_idx (which is always zero for spectrograph data
            # as there is only one longitudinal bin) can be used to index into the array the same as it would be for ASI data
            if len(mag_lats.shape) == 1:
                mag_lats = mag_lats[:, np.newaxis]
                mag_lons = mag_lons[:, np.newaxis]

            # Set the y axis to the desired slice index of the magnetic latitudes
            self.mag_y = mag_lats[:, self.__slice_idx].copy()
        else:
            # Convert middle altitude lats and lons to geomagnetic coordinates
            mag_lats, mag_lons, _ = aacgmv2.convert_latlon_arr(np.squeeze(skymap.full_map_latitude[1, :, :]).flatten(),
                                                               np.squeeze(skymap.full_map_longitude[1, :, :]).flatten(),
                                                               (skymap.full_map_longitude[1, :, :] * 0.0).flatten(),
                                                               timestamp,
                                                               method_code=&#39;G2A&#39;)
            mag_lats = np.reshape(mag_lats, np.squeeze(skymap.full_map_latitude[1, :, :]).shape)
            mag_lons = np.reshape(mag_lons, np.squeeze(skymap.full_map_longitude[1, :, :]).shape)

            # If lat/lon arrays are 1-dimensional then we know it is a spectrograph skymap. In this case, we will simply
            # reform to add an additional dimension, so that self.__slice_idx (which is always zero for spectrograph data
            # as there is only one longitudinal bin) can be used to index into the array the same as it would be for ASI data
            if len(mag_lats.shape) == 1:
                mag_lats = mag_lats[:, np.newaxis]
                mag_lons = mag_lons[:, np.newaxis]

            # Set the y axis to the desired slice index of the magnetic latitudes
            self.mag_y = mag_lats[:, self.__slice_idx].copy()

    def plot(self,
             y_type: Literal[&#34;ccd&#34;, &#34;mag&#34;, &#34;geo&#34;] = &#34;ccd&#34;,
             title: Optional[str] = None,
             figsize: Optional[Tuple[int, int]] = None,
             cmap: Optional[str] = None,
             aspect: Optional[Union[Literal[&#34;equal&#34;, &#34;auto&#34;], float]] = None,
             axes_visible: bool = True,
             xlabel: str = &#34;Time (UTC)&#34;,
             ylabel: Optional[str] = None,
             xtick_increment: Optional[int] = None,
             ytick_increment: Optional[int] = None,
             returnfig: bool = False,
             savefig: bool = False,
             savefig_filename: Optional[str] = None,
             savefig_quality: Optional[int] = None) -&gt; Any:
        &#34;&#34;&#34;
        Generate a plot of the keogram data. 
        
        Either display it (default behaviour), save it to disk (using the `savefig` parameter), or 
        return the matplotlib plot object for further usage (using the `returnfig` parameter).

        Args:
            y_type (str): 
                Type of y-axis to use when plotting. Options are `ccd`, `mag`, or `geo`. The
                default is `ccd`. This parameter is required.

            title (str): 
                The title to display above the plotted keogram. Default is no title.

            figsize (tuple): 
                The matplotlib figure size to use when plotting. For example `figsize=(14,4)`.

            cmap (str): 
                The matplotlib colormap to use.

                Commonly used colormaps are:

                - REGO: `gist_heat`
                - THEMIS ASI: `gray`
                - TREx Blue: `Blues_r`
                - TREx NIR: `gray`
                - TREx RGB: `None`

                A list of all available colormaps can be found on the 
                [matplotlib documentation](https://matplotlib.org/stable/gallery/color/colormap_reference.html).
            
            aspect (str or float): 
                The matplotlib imshow aspect ration to use. A common value for this is `auto`. All valid values 
                can be found on the [matplotlib documentation](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html).

            axes_visible (bool): 
                Display the axes. Default is `True`.

            xlabel (str): 
                The x-axis label to use. Default is `Time (UTC)`.

            ylabel (str): 
                The y-axis label to use. Default is based on y_type.

            xtick_increment (int): 
                The x-axis tick increment to use. Default is 100.

            ytick_increment (int): 
                The y-axis tick increment to use. Default is 50.

            returnfig (bool): 
                Instead of displaying the image, return the matplotlib figure object. This allows for further plot 
                manipulation, for example, adding labels or a title in a different location than the default. 
                
                Remember - if this parameter is supplied, be sure that you close your plot after finishing work 
                with it. This can be achieved by doing `plt.close(fig)`. 
                
                Note that this method cannot be used in combination with `savefig`.

            savefig (bool): 
                Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if 
                this parameter is set to True. Defaults to `False`.

            savefig_filename (str): 
                Filename to save the image to. Must be specified if the savefig parameter is set to True.

            savefig_quality (int): 
                Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
                is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow&#39;s default of 75%.

        Returns:
            The displayed keogram, by default. If `savefig` is set to True, nothing will be returned. If `returnfig` is 
            set to True, the plotting variables `(fig, ax)` will be returned.

        Raises:
            ValueError: issues encountered with the y-axis choice
        &#34;&#34;&#34;
        # check return mode
        if (returnfig is True and savefig is True):
            raise ValueError(&#34;Only one of returnfig or savefig can be set to True&#34;)
        if returnfig is True and (savefig_filename is not None or savefig_quality is not None):
            show_warning(&#34;The figure will be returned, but a savefig option parameter was supplied. Consider &#34; +
                         &#34;removing the savefig option parameter(s) as they will be ignored.&#34;,
                         stacklevel=1)
        elif savefig is False and (savefig_filename is not None or savefig_quality is not None):
            show_warning(&#34;A savefig option parameter was supplied, but the savefig parameter is False. The &#34; +
                         &#34;savefig option parameters will be ignored.&#34;,
                         stacklevel=1)

        # init figure and plot data
        fig = plt.figure(figsize=figsize)
        ax = fig.add_axes((0, 0, 1, 1))

        # If RGB, we need to normalize for matplotlib
        if len(self.data.shape) == 3:
            img_arr = self.data / 255.0
        else:
            img_arr = self.data

        ax.imshow(img_arr, origin=&#34;lower&#34;, cmap=cmap, aspect=aspect)

        # set title
        if (title is not None):
            ax.set_title(title)

        # set axes
        if (axes_visible is True):
            # do checks for y-axis that was chosen
            if (y_type == &#34;geo&#34; and self.geo_y is None):
                raise ValueError(&#34;Unable to plot using geo_y data. The geo_y attribute is currently None, so either populate &#34;
                                 &#34;it with data using the set_geographic_latitudes() function, or choose a different y_type&#34;)
            elif (y_type == &#34;mag&#34; and self.mag_y is None):
                raise ValueError(&#34;Unable to plot using mag_y data. The mag_y attribute is currently None, so either populate &#34;
                                 &#34;it with data using the set_magnetic_latitudes() function, or choose a different y_type&#34;)

            # set y axis data, and y label
            y_axis_data = self.ccd_y
            if (y_type == &#34;mag&#34;):
                y_axis_data = self.mag_y
                if (ylabel is None):
                    ylabel = &#34;Magnetic latitude&#34;
            elif (y_type == &#34;geo&#34;):
                y_axis_data = self.geo_y
                if (ylabel is None):
                    ylabel = &#34;Geographic latitude&#34;
            else:
                if (ylabel is None):
                    ylabel = &#34;CCD Y&#34;

            # print labels
            ax.set_xlabel(xlabel, fontsize=14)
            ax.set_ylabel(ylabel, fontsize=14)

            # generate x ticks and labels
            #
            # TODO: make this more dynamic
            if (xtick_increment is None):
                xtick_increment = 100  # assume data is 3 second cadence; good enough for now
            x_ticks = np.arange(0, self.data.shape[1], xtick_increment)
            x_labels = self.timestamp[::xtick_increment]
            for i in range(0, len(x_labels)):
                x_labels[i] = x_labels[i].strftime(&#34;%H:%M&#34;)  # type: ignore
            ax.set_xticks(x_ticks, x_labels)  # type: ignore

            # do check for ccd_y
            if (self.ccd_y is None):
                show_warning(
                    &#34;Unable to plot CCD y-axis. If this keogram object was create as part of the custom_keogram &#34; +
                    &#34;routines, this is expected and plotting a custom keogram with axes is not supported at this time.&#34;,
                    stacklevel=1,
                )
                ylabel = &#34;Keogram Y&#34;
            else:
                # generate y ticks and labels
                if (y_type == &#34;ccd&#34;):
                    # TODO: make this more dynamic
                    if (ytick_increment is None):
                        ytick_increment = 50

                    # generate y ticks and labels
                    y_ticks = y_axis_data[::ytick_increment]  # type: ignore
                    y_labels = y_axis_data[::ytick_increment]  # type: ignore

                    # apply yticks
                    ax.set_yticks(y_ticks, y_labels)  # type: ignore
                elif (y_type == &#34;geo&#34; and self.geo_y is not None) or (y_type == &#34;mag&#34; and self.mag_y is not None):
                    # set tick increments
                    if (ytick_increment is None):
                        ytick_increment = 50

                    # generate y ticks and labels
                    y_ticks = self.ccd_y[25::ytick_increment]
                    y_labels = np.round(
                        y_axis_data,  # type: ignore
                        1).astype(str)[25::ytick_increment]
                    y_labels[np.where(y_labels == &#39;nan&#39;)] = &#39;&#39;

                    # apply yticks
                    ax.set_yticks(y_ticks, y_labels)
        else:
            # disable axes
            ax.set_axis_off()

        # save figure or show it
        if (savefig is True):
            # check that filename has been set
            if (savefig_filename is None):
                raise ValueError(&#34;The savefig_filename parameter is missing, but required since savefig was set to True.&#34;)

            # save the figure
            f_extension = os.path.splitext(savefig_filename)[-1].lower()
            if (&#34;.jpg&#34; == f_extension or &#34;.jpeg&#34; == f_extension):
                # check quality setting
                if (savefig_quality is not None):
                    plt.savefig(savefig_filename, pil_kwargs={&#34;quality&#34;: savefig_quality}, bbox_inches=&#34;tight&#34;)
                else:
                    plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)
            else:
                if (savefig_quality is not None):
                    # quality specified, but output filename is not a JPG, so show a warning
                    show_warning(&#34;The savefig_quality parameter was specified, but is only used for saving JPG files. The &#34; +
                                 &#34;savefig_filename parameter was determined to not be a JPG file, so the quality will be ignored&#34;,
                                 stacklevel=1)
                plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)

            # clean up by closing the figure
            plt.close(fig)
        elif (returnfig is True):
            # return the figure and axis objects
            return (fig, ax)
        else:
            # show the figure
            plt.show(fig)

            # cleanup by closing the figure
            plt.close(fig)

        # return
        return None

    def inject_nans(
        self,
        cadence: Optional[Union[int, float]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Fill keogram columns that do not have data with NaNs.

        Args:
            cadence (int or float): 
                The cadence, in seconds, of the data for the keogram. Default is to automatically
                determine the cadence based on the keogram&#39;s timestamp data
        
        Returns:
            None. If there is missing data, the Keogram object&#39;s data and timestamp attributes
            will be updated accordingly.

        # Raises:
            ValueError if called on a keogram with improper / corrupted data format / shape.
        &#34;&#34;&#34;

        # First, regardless of whether or not the user supplies a cadence, determine the cadence
        # based on the keograms timestamp attribute. If the user provided cadence is different
        # then that calculated, we will raise a Warning
        apparent_cadence = _determine_cadence(self.timestamp)
        if not isinstance(apparent_cadence, (float, int)):
            raise ValueError(&#34;Could not determine cadence from object Keogram.timestamp.&#34;)  # pragma: nocover

        if (cadence is not None) and (apparent_cadence != cadence):
            warning_str = (&#34;Based on the keogram&#39;s timestamp attribute, the apparent cadence is %.2f s, but %.2f s was &#34;
                           &#34;passed in as an argument. Ensure that the selected cadence of %.2f s is correct for the dataset being used.&#34;)
            show_warning(warning_str % (apparent_cadence, cadence, cadence), stacklevel=1)

        # If a cadence was not supplied by the user, then use the apparent cadence calculated based on timestamps
        if cadence is None:
            cadence = apparent_cadence

        # The first step is checking if there actually is any missing data in this keogram. To do this we
        # find the total number of frames that there should be, based on the first and last timestamp, and
        # check if there are indeed that many frames in the keogram
        start_dt = self.timestamp[0]
        end_dt = self.timestamp[-1]

        # If cadence is supplied as or calculated to be (burst) a float, it needs to be
        # handled on the order of milliseconds
        if isinstance(cadence, float):

            n_desired_frames = round(((end_dt - start_dt).seconds + (end_dt - start_dt).microseconds * 10**(-6)) / cadence + 1)
            n_keogram_frames = (self.data.shape)[1]

            if cadence &lt; 1.0:
                is_burst = True
            else:
                is_burst = False

        # Otherwise, handle timestamps on the order of seconds
        else:
            n_desired_frames = round(((end_dt - start_dt).seconds) / cadence + 1)
            n_keogram_frames = (self.data.shape)[1]
            is_burst = False

        # If the keogram is not missing any data, nothing is changed
        if n_desired_frames == n_keogram_frames:
            return

        # Otherwise, we need to find which desired timestamps are missing

        # First, create a new keogram array and new timestamp list with the correct size for the desired number of frames
        if len(self.data.shape) == 2:
            desired_keogram_shape = (self.data.shape[0], n_desired_frames)
        elif len(self.data.shape) == 3:
            desired_keogram_shape = (self.data.shape[0], n_desired_frames, self.data.shape[2])
        else:
            raise ValueError(f&#34;Could not inject NaNs into keogram with data shape {self.data.shape}&#34;)  # pragma: nocover

        desired_keogram = np.empty(shape=desired_keogram_shape)
        desired_timestamp = []
        desired_timestamp_indices = []

        if is_burst:
            tol = datetime.timedelta(seconds=(1.0 / 6.0))
        else:
            tol = datetime.timedelta(seconds=1.0)

        # Fill the list of desired timestamps based on the cadence

        # For each *desired* timestamp, we use a binary search to determine whether
        # or not that timestamp already exists in the data, within tolerance
        target_dt = start_dt
        for _ in range(n_desired_frames):

            low = 0
            high = len(self.timestamp) - 1
            match_idx = None

            # binary search
            while low &lt;= high:
                mid = (low + high) // 2
                mid_ts = self.timestamp[mid]

                if mid_ts &lt; target_dt - tol:
                    low = mid + 1
                elif mid_ts &gt; target_dt + tol:
                    high = mid - 1
                else:
                    # Match, within tolerance, has been found
                    match_idx = mid

                    high = mid - 1

            # If we&#39;ve found a matching timestamp, insert it into the new timestamp array, and
            # otherwise insert the desired timestamp
            if match_idx is not None:
                desired_timestamp.append(self.timestamp[match_idx])
            else:
                desired_timestamp.append(target_dt)

            # Add the index into the original keogram corresponding to this timestamp if it exists
            # and otherwise add None to the index tracking list, which we will use to insert the
            # data and NaN columns
            desired_timestamp_indices.append(match_idx)

            # Update the desired datetime according to the cadence
            target_dt += datetime.timedelta(seconds=cadence)

        # Now that we have our desired timestamps, we can go through and fill the new keogram array
        for i in range(len(desired_timestamp)):

            keo_idx = desired_timestamp_indices[i]

            # If this desired timestamp had no data, fill the keogram column with nans
            if keo_idx is None:
                desired_keogram[:, i] = np.nan
            # Otherwise, keep the data intact for this column
            else:
                desired_keogram[:, i] = self.data[:, keo_idx]

        # Update the keogram object with the new data and timestamp arrays
        self.data = desired_keogram
        self.timestamp = desired_timestamp</code></pre>
</details>
<div class="desc"><p>Class representation for a keogram</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>The derived keogram data.</dd>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>List[datetime.datetime]</code></dt>
<dd>Timestamps corresponding to each keogram slice.</dd>
<dt><strong><code>instrument_type</code></strong> :&ensp;<code>str</code></dt>
<dd>String giving instrument type, either 'asi' or 'spectrograph'.</dd>
<dt><strong><code>ccd_y</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>The y-axis representing CCD Y coordinates for the keogram.</dd>
<dt><strong><code>mag_y</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>The y-axis representing magnetic latitude for the keogram.</dd>
<dt><strong><code>geo_y</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>The y-axis representing geographic latitude for the keogram.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.tools.classes.keogram.Keogram.inject_nans"><code class="name flex">
<span>def <span class="ident">inject_nans</span></span>(<span>self, cadence: int | float | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inject_nans(
    self,
    cadence: Optional[Union[int, float]] = None,
) -&gt; None:
    &#34;&#34;&#34;
    Fill keogram columns that do not have data with NaNs.

    Args:
        cadence (int or float): 
            The cadence, in seconds, of the data for the keogram. Default is to automatically
            determine the cadence based on the keogram&#39;s timestamp data
    
    Returns:
        None. If there is missing data, the Keogram object&#39;s data and timestamp attributes
        will be updated accordingly.

    # Raises:
        ValueError if called on a keogram with improper / corrupted data format / shape.
    &#34;&#34;&#34;

    # First, regardless of whether or not the user supplies a cadence, determine the cadence
    # based on the keograms timestamp attribute. If the user provided cadence is different
    # then that calculated, we will raise a Warning
    apparent_cadence = _determine_cadence(self.timestamp)
    if not isinstance(apparent_cadence, (float, int)):
        raise ValueError(&#34;Could not determine cadence from object Keogram.timestamp.&#34;)  # pragma: nocover

    if (cadence is not None) and (apparent_cadence != cadence):
        warning_str = (&#34;Based on the keogram&#39;s timestamp attribute, the apparent cadence is %.2f s, but %.2f s was &#34;
                       &#34;passed in as an argument. Ensure that the selected cadence of %.2f s is correct for the dataset being used.&#34;)
        show_warning(warning_str % (apparent_cadence, cadence, cadence), stacklevel=1)

    # If a cadence was not supplied by the user, then use the apparent cadence calculated based on timestamps
    if cadence is None:
        cadence = apparent_cadence

    # The first step is checking if there actually is any missing data in this keogram. To do this we
    # find the total number of frames that there should be, based on the first and last timestamp, and
    # check if there are indeed that many frames in the keogram
    start_dt = self.timestamp[0]
    end_dt = self.timestamp[-1]

    # If cadence is supplied as or calculated to be (burst) a float, it needs to be
    # handled on the order of milliseconds
    if isinstance(cadence, float):

        n_desired_frames = round(((end_dt - start_dt).seconds + (end_dt - start_dt).microseconds * 10**(-6)) / cadence + 1)
        n_keogram_frames = (self.data.shape)[1]

        if cadence &lt; 1.0:
            is_burst = True
        else:
            is_burst = False

    # Otherwise, handle timestamps on the order of seconds
    else:
        n_desired_frames = round(((end_dt - start_dt).seconds) / cadence + 1)
        n_keogram_frames = (self.data.shape)[1]
        is_burst = False

    # If the keogram is not missing any data, nothing is changed
    if n_desired_frames == n_keogram_frames:
        return

    # Otherwise, we need to find which desired timestamps are missing

    # First, create a new keogram array and new timestamp list with the correct size for the desired number of frames
    if len(self.data.shape) == 2:
        desired_keogram_shape = (self.data.shape[0], n_desired_frames)
    elif len(self.data.shape) == 3:
        desired_keogram_shape = (self.data.shape[0], n_desired_frames, self.data.shape[2])
    else:
        raise ValueError(f&#34;Could not inject NaNs into keogram with data shape {self.data.shape}&#34;)  # pragma: nocover

    desired_keogram = np.empty(shape=desired_keogram_shape)
    desired_timestamp = []
    desired_timestamp_indices = []

    if is_burst:
        tol = datetime.timedelta(seconds=(1.0 / 6.0))
    else:
        tol = datetime.timedelta(seconds=1.0)

    # Fill the list of desired timestamps based on the cadence

    # For each *desired* timestamp, we use a binary search to determine whether
    # or not that timestamp already exists in the data, within tolerance
    target_dt = start_dt
    for _ in range(n_desired_frames):

        low = 0
        high = len(self.timestamp) - 1
        match_idx = None

        # binary search
        while low &lt;= high:
            mid = (low + high) // 2
            mid_ts = self.timestamp[mid]

            if mid_ts &lt; target_dt - tol:
                low = mid + 1
            elif mid_ts &gt; target_dt + tol:
                high = mid - 1
            else:
                # Match, within tolerance, has been found
                match_idx = mid

                high = mid - 1

        # If we&#39;ve found a matching timestamp, insert it into the new timestamp array, and
        # otherwise insert the desired timestamp
        if match_idx is not None:
            desired_timestamp.append(self.timestamp[match_idx])
        else:
            desired_timestamp.append(target_dt)

        # Add the index into the original keogram corresponding to this timestamp if it exists
        # and otherwise add None to the index tracking list, which we will use to insert the
        # data and NaN columns
        desired_timestamp_indices.append(match_idx)

        # Update the desired datetime according to the cadence
        target_dt += datetime.timedelta(seconds=cadence)

    # Now that we have our desired timestamps, we can go through and fill the new keogram array
    for i in range(len(desired_timestamp)):

        keo_idx = desired_timestamp_indices[i]

        # If this desired timestamp had no data, fill the keogram column with nans
        if keo_idx is None:
            desired_keogram[:, i] = np.nan
        # Otherwise, keep the data intact for this column
        else:
            desired_keogram[:, i] = self.data[:, keo_idx]

    # Update the keogram object with the new data and timestamp arrays
    self.data = desired_keogram
    self.timestamp = desired_timestamp</code></pre>
</details>
<div class="desc"><p>Fill keogram columns that do not have data with NaNs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cadence</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>The cadence, in seconds, of the data for the keogram. Default is to automatically
determine the cadence based on the keogram's timestamp data</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None. If there is missing data, the Keogram object's data and timestamp attributes
will be updated accordingly.</p>
<h1 id="raises">Raises:</h1>
<pre><code>ValueError if called on a keogram with improper / corrupted data format / shape.
</code></pre></div>
</dd>
<dt id="pyaurorax.tools.classes.keogram.Keogram.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self,<br>y_type: Literal['ccd', 'mag', 'geo'] = 'ccd',<br>title: str | None = None,<br>figsize: Tuple[int, int] | None = None,<br>cmap: str | None = None,<br>aspect: Literal['equal', 'auto'] | float | None = None,<br>axes_visible: bool = True,<br>xlabel: str = 'Time (UTC)',<br>ylabel: str | None = None,<br>xtick_increment: int | None = None,<br>ytick_increment: int | None = None,<br>returnfig: bool = False,<br>savefig: bool = False,<br>savefig_filename: str | None = None,<br>savefig_quality: int | None = None) ‑> Any</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         y_type: Literal[&#34;ccd&#34;, &#34;mag&#34;, &#34;geo&#34;] = &#34;ccd&#34;,
         title: Optional[str] = None,
         figsize: Optional[Tuple[int, int]] = None,
         cmap: Optional[str] = None,
         aspect: Optional[Union[Literal[&#34;equal&#34;, &#34;auto&#34;], float]] = None,
         axes_visible: bool = True,
         xlabel: str = &#34;Time (UTC)&#34;,
         ylabel: Optional[str] = None,
         xtick_increment: Optional[int] = None,
         ytick_increment: Optional[int] = None,
         returnfig: bool = False,
         savefig: bool = False,
         savefig_filename: Optional[str] = None,
         savefig_quality: Optional[int] = None) -&gt; Any:
    &#34;&#34;&#34;
    Generate a plot of the keogram data. 
    
    Either display it (default behaviour), save it to disk (using the `savefig` parameter), or 
    return the matplotlib plot object for further usage (using the `returnfig` parameter).

    Args:
        y_type (str): 
            Type of y-axis to use when plotting. Options are `ccd`, `mag`, or `geo`. The
            default is `ccd`. This parameter is required.

        title (str): 
            The title to display above the plotted keogram. Default is no title.

        figsize (tuple): 
            The matplotlib figure size to use when plotting. For example `figsize=(14,4)`.

        cmap (str): 
            The matplotlib colormap to use.

            Commonly used colormaps are:

            - REGO: `gist_heat`
            - THEMIS ASI: `gray`
            - TREx Blue: `Blues_r`
            - TREx NIR: `gray`
            - TREx RGB: `None`

            A list of all available colormaps can be found on the 
            [matplotlib documentation](https://matplotlib.org/stable/gallery/color/colormap_reference.html).
        
        aspect (str or float): 
            The matplotlib imshow aspect ration to use. A common value for this is `auto`. All valid values 
            can be found on the [matplotlib documentation](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html).

        axes_visible (bool): 
            Display the axes. Default is `True`.

        xlabel (str): 
            The x-axis label to use. Default is `Time (UTC)`.

        ylabel (str): 
            The y-axis label to use. Default is based on y_type.

        xtick_increment (int): 
            The x-axis tick increment to use. Default is 100.

        ytick_increment (int): 
            The y-axis tick increment to use. Default is 50.

        returnfig (bool): 
            Instead of displaying the image, return the matplotlib figure object. This allows for further plot 
            manipulation, for example, adding labels or a title in a different location than the default. 
            
            Remember - if this parameter is supplied, be sure that you close your plot after finishing work 
            with it. This can be achieved by doing `plt.close(fig)`. 
            
            Note that this method cannot be used in combination with `savefig`.

        savefig (bool): 
            Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if 
            this parameter is set to True. Defaults to `False`.

        savefig_filename (str): 
            Filename to save the image to. Must be specified if the savefig parameter is set to True.

        savefig_quality (int): 
            Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
            is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow&#39;s default of 75%.

    Returns:
        The displayed keogram, by default. If `savefig` is set to True, nothing will be returned. If `returnfig` is 
        set to True, the plotting variables `(fig, ax)` will be returned.

    Raises:
        ValueError: issues encountered with the y-axis choice
    &#34;&#34;&#34;
    # check return mode
    if (returnfig is True and savefig is True):
        raise ValueError(&#34;Only one of returnfig or savefig can be set to True&#34;)
    if returnfig is True and (savefig_filename is not None or savefig_quality is not None):
        show_warning(&#34;The figure will be returned, but a savefig option parameter was supplied. Consider &#34; +
                     &#34;removing the savefig option parameter(s) as they will be ignored.&#34;,
                     stacklevel=1)
    elif savefig is False and (savefig_filename is not None or savefig_quality is not None):
        show_warning(&#34;A savefig option parameter was supplied, but the savefig parameter is False. The &#34; +
                     &#34;savefig option parameters will be ignored.&#34;,
                     stacklevel=1)

    # init figure and plot data
    fig = plt.figure(figsize=figsize)
    ax = fig.add_axes((0, 0, 1, 1))

    # If RGB, we need to normalize for matplotlib
    if len(self.data.shape) == 3:
        img_arr = self.data / 255.0
    else:
        img_arr = self.data

    ax.imshow(img_arr, origin=&#34;lower&#34;, cmap=cmap, aspect=aspect)

    # set title
    if (title is not None):
        ax.set_title(title)

    # set axes
    if (axes_visible is True):
        # do checks for y-axis that was chosen
        if (y_type == &#34;geo&#34; and self.geo_y is None):
            raise ValueError(&#34;Unable to plot using geo_y data. The geo_y attribute is currently None, so either populate &#34;
                             &#34;it with data using the set_geographic_latitudes() function, or choose a different y_type&#34;)
        elif (y_type == &#34;mag&#34; and self.mag_y is None):
            raise ValueError(&#34;Unable to plot using mag_y data. The mag_y attribute is currently None, so either populate &#34;
                             &#34;it with data using the set_magnetic_latitudes() function, or choose a different y_type&#34;)

        # set y axis data, and y label
        y_axis_data = self.ccd_y
        if (y_type == &#34;mag&#34;):
            y_axis_data = self.mag_y
            if (ylabel is None):
                ylabel = &#34;Magnetic latitude&#34;
        elif (y_type == &#34;geo&#34;):
            y_axis_data = self.geo_y
            if (ylabel is None):
                ylabel = &#34;Geographic latitude&#34;
        else:
            if (ylabel is None):
                ylabel = &#34;CCD Y&#34;

        # print labels
        ax.set_xlabel(xlabel, fontsize=14)
        ax.set_ylabel(ylabel, fontsize=14)

        # generate x ticks and labels
        #
        # TODO: make this more dynamic
        if (xtick_increment is None):
            xtick_increment = 100  # assume data is 3 second cadence; good enough for now
        x_ticks = np.arange(0, self.data.shape[1], xtick_increment)
        x_labels = self.timestamp[::xtick_increment]
        for i in range(0, len(x_labels)):
            x_labels[i] = x_labels[i].strftime(&#34;%H:%M&#34;)  # type: ignore
        ax.set_xticks(x_ticks, x_labels)  # type: ignore

        # do check for ccd_y
        if (self.ccd_y is None):
            show_warning(
                &#34;Unable to plot CCD y-axis. If this keogram object was create as part of the custom_keogram &#34; +
                &#34;routines, this is expected and plotting a custom keogram with axes is not supported at this time.&#34;,
                stacklevel=1,
            )
            ylabel = &#34;Keogram Y&#34;
        else:
            # generate y ticks and labels
            if (y_type == &#34;ccd&#34;):
                # TODO: make this more dynamic
                if (ytick_increment is None):
                    ytick_increment = 50

                # generate y ticks and labels
                y_ticks = y_axis_data[::ytick_increment]  # type: ignore
                y_labels = y_axis_data[::ytick_increment]  # type: ignore

                # apply yticks
                ax.set_yticks(y_ticks, y_labels)  # type: ignore
            elif (y_type == &#34;geo&#34; and self.geo_y is not None) or (y_type == &#34;mag&#34; and self.mag_y is not None):
                # set tick increments
                if (ytick_increment is None):
                    ytick_increment = 50

                # generate y ticks and labels
                y_ticks = self.ccd_y[25::ytick_increment]
                y_labels = np.round(
                    y_axis_data,  # type: ignore
                    1).astype(str)[25::ytick_increment]
                y_labels[np.where(y_labels == &#39;nan&#39;)] = &#39;&#39;

                # apply yticks
                ax.set_yticks(y_ticks, y_labels)
    else:
        # disable axes
        ax.set_axis_off()

    # save figure or show it
    if (savefig is True):
        # check that filename has been set
        if (savefig_filename is None):
            raise ValueError(&#34;The savefig_filename parameter is missing, but required since savefig was set to True.&#34;)

        # save the figure
        f_extension = os.path.splitext(savefig_filename)[-1].lower()
        if (&#34;.jpg&#34; == f_extension or &#34;.jpeg&#34; == f_extension):
            # check quality setting
            if (savefig_quality is not None):
                plt.savefig(savefig_filename, pil_kwargs={&#34;quality&#34;: savefig_quality}, bbox_inches=&#34;tight&#34;)
            else:
                plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)
        else:
            if (savefig_quality is not None):
                # quality specified, but output filename is not a JPG, so show a warning
                show_warning(&#34;The savefig_quality parameter was specified, but is only used for saving JPG files. The &#34; +
                             &#34;savefig_filename parameter was determined to not be a JPG file, so the quality will be ignored&#34;,
                             stacklevel=1)
            plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)

        # clean up by closing the figure
        plt.close(fig)
    elif (returnfig is True):
        # return the figure and axis objects
        return (fig, ax)
    else:
        # show the figure
        plt.show(fig)

        # cleanup by closing the figure
        plt.close(fig)

    # return
    return None</code></pre>
</details>
<div class="desc"><p>Generate a plot of the keogram data. </p>
<p>Either display it (default behaviour), save it to disk (using the <code>savefig</code> parameter), or
return the matplotlib plot object for further usage (using the <code>returnfig</code> parameter).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of y-axis to use when plotting. Options are <code>ccd</code>, <code>mag</code>, or <code>geo</code>. The
default is <code>ccd</code>. This parameter is required.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>The title to display above the plotted keogram. Default is no title.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The matplotlib figure size to use when plotting. For example <code>figsize=(14,4)</code>.</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>The matplotlib colormap to use.</p>
<p>Commonly used colormaps are:</p>
<ul>
<li>REGO: <code>gist_heat</code></li>
<li>THEMIS ASI: <code>gray</code></li>
<li>TREx Blue: <code>Blues_r</code></li>
<li>TREx NIR: <code>gray</code></li>
<li>TREx RGB: <code>None</code></li>
</ul>
<p>A list of all available colormaps can be found on the
<a href="https://matplotlib.org/stable/gallery/color/colormap_reference.html">matplotlib documentation</a>.</p>
</dd>
<dt><strong><code>aspect</code></strong> :&ensp;<code>str</code> or <code>float</code></dt>
<dd>The matplotlib imshow aspect ration to use. A common value for this is <code>auto</code>. All valid values
can be found on the <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html">matplotlib documentation</a>.</dd>
<dt><strong><code>axes_visible</code></strong> :&ensp;<code>bool</code></dt>
<dd>Display the axes. Default is <code>True</code>.</dd>
<dt><strong><code>xlabel</code></strong> :&ensp;<code>str</code></dt>
<dd>The x-axis label to use. Default is <code>Time (UTC)</code>.</dd>
<dt><strong><code>ylabel</code></strong> :&ensp;<code>str</code></dt>
<dd>The y-axis label to use. Default is based on y_type.</dd>
<dt><strong><code>xtick_increment</code></strong> :&ensp;<code>int</code></dt>
<dd>The x-axis tick increment to use. Default is 100.</dd>
<dt><strong><code>ytick_increment</code></strong> :&ensp;<code>int</code></dt>
<dd>The y-axis tick increment to use. Default is 50.</dd>
<dt><strong><code>returnfig</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Instead of displaying the image, return the matplotlib figure object. This allows for further plot
manipulation, for example, adding labels or a title in a different location than the default. </p>
<p>Remember - if this parameter is supplied, be sure that you close your plot after finishing work
with it. This can be achieved by doing <code>plt.close(fig)</code>. </p>
<p>Note that this method cannot be used in combination with <code>savefig</code>.</p>
</dd>
<dt><strong><code>savefig</code></strong> :&ensp;<code>bool</code></dt>
<dd>Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if
this parameter is set to True. Defaults to <code>False</code>.</dd>
<dt><strong><code>savefig_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename to save the image to. Must be specified if the savefig parameter is set to True.</dd>
<dt><strong><code>savefig_quality</code></strong> :&ensp;<code>int</code></dt>
<dd>Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow's default of 75%.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The displayed keogram, by default. If <code>savefig</code> is set to True, nothing will be returned. If <code>returnfig</code> is
set to True, the plotting variables <code>(fig, ax)</code> will be returned.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>issues encountered with the y-axis choice</dd>
</dl></div>
</dd>
<dt id="pyaurorax.tools.classes.keogram.Keogram.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(self):
    &#34;&#34;&#34;
    A special print output for this class.
    &#34;&#34;&#34;
    # set special strings
    data_str = &#34;array(dims=%s, dtype=%s)&#34; % (self.data.shape, self.data.dtype)
    timestamp_str = &#34;[%d datetime objects]&#34; % (len(self.timestamp))
    ccd_y_str = &#34;None&#34; if self.ccd_y is None else &#34;array(%d values)&#34; % (self.ccd_y.shape[0])
    mag_y_str = &#34;None&#34; if self.mag_y is None else &#34;array(%d values)&#34; % (self.mag_y.shape[0])
    geo_y_str = &#34;None&#34; if self.geo_y is None else &#34;array(%d values)&#34; % (self.geo_y.shape[0])

    # print
    print(&#34;Keogram:&#34;)
    print(&#34;  %-17s: %s&#34; % (&#34;data&#34;, data_str))
    print(&#34;  %-17s: %s&#34; % (&#34;timestamp&#34;, timestamp_str))
    print(&#34;  %-17s: %s&#34; % (&#34;instrument_type&#34;, self.instrument_type))
    print(&#34;  %-17s: %s&#34; % (&#34;ccd_y&#34;, ccd_y_str))
    print(&#34;  %-17s: %s&#34; % (&#34;geo_y&#34;, geo_y_str))
    print(&#34;  %-17s: %s&#34; % (&#34;mag_y&#34;, mag_y_str))</code></pre>
</details>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
<dt id="pyaurorax.tools.classes.keogram.Keogram.set_geographic_latitudes"><code class="name flex">
<span>def <span class="ident">set_geographic_latitudes</span></span>(<span>self,<br>skymap: pyucalgarysrs.data.classes.Skymap,<br>altitude_km: int | float | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_geographic_latitudes(self, skymap: Skymap, altitude_km: Optional[Union[int, float]] = None) -&gt; None:
    &#34;&#34;&#34;
    Set the geographic latitude values for this keogram, using the specified skymap 
    data. The data will be set to the geo_y attribute of this Keogram object, which
    can then be used for plotting and/or further analysis.

    Args:
        skymap (pyaurorax.data.ucalgary.Skymap): 
            The skymap object to use. This parameter is required.

        altitude_km (int): 
            The altitude to use, in kilometers. If not specified, it will use the default in the 
            skymap object. If the specified altitude is not valid, a ValueError will be raised.
    
    Returns:
        None. The Keogram object&#39;s `geo_y` attribute will be updated.

    Raises:
        ValueError: Issues with specified altitude.
    &#34;&#34;&#34;
    # check for slice idx
    if (self.__slice_idx is None):

        raise ValueError(&#34;Unable to set the geographic latitudes since the private slice_idx is None. If this keogram &#34; +
                         &#34;object was created as part of the custom_keogram routines or is a spectrogaph keogram, &#34; +
                         &#34;this is expected and performing this action is not supported at this time.&#34;)

    # Check the dimensions of the skymap lat/lon arrays
    # If they are 2-dimensional [altitude_idx, y] instead of [altitude_idx, y, x] then we know it is a spectrograph
    # skymap. In this case, we will simply reform to add an additional dimension, so that self.__slice_idx (which is
    # always zero for spectrograph data as there is only one longitudinal bin) can be used to index into the array
    # the same as it would be for ASI data
    if len(skymap.full_map_latitude.shape) == 2:
        # Reform all spectrograph skymap arrays to have an extra dimension, for indexing purposes
        skymap.full_map_latitude = skymap.full_map_latitude[:, :, np.newaxis]
        skymap.full_map_longitude = skymap.full_map_longitude[:, :, np.newaxis]
        skymap.full_elevation = skymap.full_elevation[:, np.newaxis]

    # determine altitude index to use
    if (altitude_km is not None):
        # Obtain lat/lon arrays from skymap
        if (altitude_km * 1000.0 in skymap.full_map_altitude):
            altitude_idx = np.where(altitude_km * 1000.0 == skymap.full_map_altitude)

            if skymap.full_map_latitude.shape[-1] == 1:
                self.geo_y = np.squeeze(skymap.full_map_latitude[altitude_idx, :, 0]).copy()
            else:
                self.geo_y = np.squeeze(skymap.full_map_latitude[altitude_idx, :, self.__slice_idx]).copy()
        else:
            # Make sure altitude is in range that can be interpolated
            if (altitude_km * 1000.0 &lt; skymap.full_map_altitude[0]) or (altitude_km * 1000.0 &gt; skymap.full_map_altitude[2]):
                raise ValueError(&#34;Altitude &#34; + str(altitude_km) + &#34; outside valid range of &#34; +
                                 str((skymap.full_map_altitude[0] / 1000.0, skymap.full_map_altitude[2] / 1000.0)))

            # Initialze empty lat/lon arrays
            lats = np.full(np.squeeze(skymap.full_map_latitude[0, :, :]).shape, np.nan, dtype=skymap.full_map_latitude[0, :, :].dtype)

            # Interpolate lats and lons at desired altitude
            for i in range(skymap.full_map_latitude.shape[1]):
                for j in range(skymap.full_map_latitude.shape[2]):
                    lats[i, j] = np.interp(altitude_km * 1000.0, skymap.full_map_altitude, skymap.full_map_latitude[:, i, j])

            self.geo_y = lats[:, self.__slice_idx].copy()
    else:
        # use default middle altitude
        if skymap.full_map_latitude.shape[-1] == 1:
            self.geo_y = np.squeeze(skymap.full_map_latitude[1, :, 0]).copy()
        else:
            self.geo_y = np.squeeze(skymap.full_map_latitude[1, :, self.__slice_idx]).copy()</code></pre>
</details>
<div class="desc"><p>Set the geographic latitude values for this keogram, using the specified skymap
data. The data will be set to the geo_y attribute of this Keogram object, which
can then be used for plotting and/or further analysis.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>skymap</code></strong> :&ensp;<code><a title="pyaurorax.data.ucalgary.Skymap" href="../../data/ucalgary/index.html#pyaurorax.data.ucalgary.Skymap">Skymap</a></code></dt>
<dd>The skymap object to use. This parameter is required.</dd>
<dt><strong><code>altitude_km</code></strong> :&ensp;<code>int</code></dt>
<dd>The altitude to use, in kilometers. If not specified, it will use the default in the
skymap object. If the specified altitude is not valid, a ValueError will be raised.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None. The Keogram object's <code>geo_y</code> attribute will be updated.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Issues with specified altitude.</dd>
</dl></div>
</dd>
<dt id="pyaurorax.tools.classes.keogram.Keogram.set_magnetic_latitudes"><code class="name flex">
<span>def <span class="ident">set_magnetic_latitudes</span></span>(<span>self,<br>skymap: pyucalgarysrs.data.classes.Skymap,<br>timestamp: datetime.datetime,<br>altitude_km: int | float | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_magnetic_latitudes(self, skymap: Skymap, timestamp: datetime.datetime, altitude_km: Optional[Union[int, float]] = None) -&gt; None:
    &#34;&#34;&#34;
    Set the magnetic latitude values for this keogram, using the specified skymap 
    data. AACGMv2 will be utilized to perform the calculations. The resulting data
    will be set to the mag_y attribute of this Keogram object, which can then be
    used for plotting and/or further analysis.

    Args:
        skymap (pyaurorax.data.ucalgary.Skymap): 
            The skymap object to use. This parameter is required.

        timestamp (datetime.datetime): 
            The timestamp to use when converting skymap data to magnetic coordinates. Utilizes
            AACGMv2 to do the conversion.

        altitude_km (int): 
            The altitude to use. If not specified, it will use the default in the skymap
            object. If the specified altitude is not valid, a ValueError will be raised.
    
    Returns:
        None. The Keogram object&#39;s `mag_y` attribute will be updated.

    Raises:
        ValueError: Issues with specified altitude.
    &#34;&#34;&#34;

    # check for slice idx
    if (self.__slice_idx is None):
        raise ValueError(&#34;Unable to set the magnetic latitudes since the slice_idx is None. If this keogram &#34; +
                         &#34;object was created as part of the custom_keogram routines or is a spectrogaph keogram, &#34; +
                         &#34;this is expected and performing this action is not supported at this time.&#34;)

    # Check the dimensions of the skymap lat/lon arrays
    # If they are 2-dimensional [altitude_idx, y] instead of [altitude_idx, y, x] then we know it is a spectrograph
    # skymap. In this case, we will simply reform to add an additional dimension, so that self.__slice_idx (which is
    # always zero for spectrograph data as there is only one longitudinal bin) can be used to index into the array
    # the same as it would be for ASI data
    if len(skymap.full_map_latitude.shape) == 2:
        # Reform all spectrograph skymap arrays to have an extra dimension, for indexing purposes
        skymap.full_map_latitude = skymap.full_map_latitude[:, :, np.newaxis]
        skymap.full_map_longitude = skymap.full_map_longitude[:, :, np.newaxis]
        skymap.full_elevation = skymap.full_elevation[:, np.newaxis]

    # determine altitude index to use
    if (altitude_km is not None):
        # Obtain lat/lon arrays from skymap
        if (altitude_km * 1000.0 in skymap.full_map_altitude):
            altitude_idx = np.where(altitude_km * 1000.0 == skymap.full_map_altitude)

            lats = np.squeeze(skymap.full_map_latitude[altitude_idx, :, :])
            lons = np.squeeze(skymap.full_map_longitude[altitude_idx, :, :])
            lons[np.where(lons &gt; 180)] -= 360.0

        else:
            # Make sure altitude is in range that can be interpolated
            if (altitude_km * 1000.0 &lt; skymap.full_map_altitude[0]) or (altitude_km * 1000.0 &gt; skymap.full_map_altitude[2]):
                raise ValueError(&#34;Altitude &#34; + str(altitude_km) + &#34; outside valid range of &#34; +
                                 str((skymap.full_map_altitude[0] / 1000.0, skymap.full_map_altitude[2] / 1000.0)))

            # Initialze empty lat/lon arrays
            lats = np.full(np.squeeze(skymap.full_map_latitude[0, :, :]).shape, np.nan, dtype=skymap.full_map_latitude[0, :, :].dtype)
            lons = lats.copy()

            # Interpolate lats and lons at desired altitude
            for i in range(skymap.full_map_latitude.shape[1]):
                for j in range(skymap.full_map_latitude.shape[2]):
                    lats[i, j] = np.interp(altitude_km * 1000.0, skymap.full_map_altitude, skymap.full_map_latitude[:, i, j])
                    lons[i, j] = np.interp(altitude_km * 1000.0, skymap.full_map_altitude, skymap.full_map_longitude[:, i, j])

            lons[np.where(lons &gt; 180)] -= 360.0

        # Convert lats and lons to geomagnetic coordinates
        mag_lats, mag_lons, _ = aacgmv2.convert_latlon_arr(lats.flatten(), lons.flatten(), (lons * 0.0).flatten(), timestamp, method_code=&#39;G2A&#39;)
        mag_lats = np.reshape(mag_lats, lats.shape)
        mag_lons = np.reshape(mag_lons, lons.shape)

        # If lat/lon arrays are 1-dimensional then we know it is a spectrograph skymap. In this case, we will simply
        # reform to add an additional dimension, so that self.__slice_idx (which is always zero for spectrograph data
        # as there is only one longitudinal bin) can be used to index into the array the same as it would be for ASI data
        if len(mag_lats.shape) == 1:
            mag_lats = mag_lats[:, np.newaxis]
            mag_lons = mag_lons[:, np.newaxis]

        # Set the y axis to the desired slice index of the magnetic latitudes
        self.mag_y = mag_lats[:, self.__slice_idx].copy()
    else:
        # Convert middle altitude lats and lons to geomagnetic coordinates
        mag_lats, mag_lons, _ = aacgmv2.convert_latlon_arr(np.squeeze(skymap.full_map_latitude[1, :, :]).flatten(),
                                                           np.squeeze(skymap.full_map_longitude[1, :, :]).flatten(),
                                                           (skymap.full_map_longitude[1, :, :] * 0.0).flatten(),
                                                           timestamp,
                                                           method_code=&#39;G2A&#39;)
        mag_lats = np.reshape(mag_lats, np.squeeze(skymap.full_map_latitude[1, :, :]).shape)
        mag_lons = np.reshape(mag_lons, np.squeeze(skymap.full_map_longitude[1, :, :]).shape)

        # If lat/lon arrays are 1-dimensional then we know it is a spectrograph skymap. In this case, we will simply
        # reform to add an additional dimension, so that self.__slice_idx (which is always zero for spectrograph data
        # as there is only one longitudinal bin) can be used to index into the array the same as it would be for ASI data
        if len(mag_lats.shape) == 1:
            mag_lats = mag_lats[:, np.newaxis]
            mag_lons = mag_lons[:, np.newaxis]

        # Set the y axis to the desired slice index of the magnetic latitudes
        self.mag_y = mag_lats[:, self.__slice_idx].copy()</code></pre>
</details>
<div class="desc"><p>Set the magnetic latitude values for this keogram, using the specified skymap
data. AACGMv2 will be utilized to perform the calculations. The resulting data
will be set to the mag_y attribute of this Keogram object, which can then be
used for plotting and/or further analysis.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>skymap</code></strong> :&ensp;<code><a title="pyaurorax.data.ucalgary.Skymap" href="../../data/ucalgary/index.html#pyaurorax.data.ucalgary.Skymap">Skymap</a></code></dt>
<dd>The skymap object to use. This parameter is required.</dd>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>The timestamp to use when converting skymap data to magnetic coordinates. Utilizes
AACGMv2 to do the conversion.</dd>
<dt><strong><code>altitude_km</code></strong> :&ensp;<code>int</code></dt>
<dd>The altitude to use. If not specified, it will use the default in the skymap
object. If the specified altitude is not valid, a ValueError will be raised.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None. The Keogram object's <code>mag_y</code> attribute will be updated.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Issues with specified altitude.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.css" integrity="sha512-b+T2i3P45i1LZM7I00Ci5QquB9szqaxu+uuk5TUSGjZQ4w4n+qujQiIuvTv2BxE7WCGQCifNMksyKILDiHzsOg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.js" integrity="sha512-2B9/byNV1KKRm5nQ2RLViPFD6U4dUjDGwuW1GU+ImJh8YinPU9Zlq1GzdTMO+G2ROrB5o1qasJBy1ttYz0wCug==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyaurorax.tools.classes" href="index.html">pyaurorax.tools.classes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyaurorax.tools.classes.keogram.Keogram" href="#pyaurorax.tools.classes.keogram.Keogram">Keogram</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.tools.classes.keogram.Keogram.inject_nans" href="#pyaurorax.tools.classes.keogram.Keogram.inject_nans">inject_nans</a></code></li>
<li><code><a title="pyaurorax.tools.classes.keogram.Keogram.plot" href="#pyaurorax.tools.classes.keogram.Keogram.plot">plot</a></code></li>
<li><code><a title="pyaurorax.tools.classes.keogram.Keogram.pretty_print" href="#pyaurorax.tools.classes.keogram.Keogram.pretty_print">pretty_print</a></code></li>
<li><code><a title="pyaurorax.tools.classes.keogram.Keogram.set_geographic_latitudes" href="#pyaurorax.tools.classes.keogram.Keogram.set_geographic_latitudes">set_geographic_latitudes</a></code></li>
<li><code><a title="pyaurorax.tools.classes.keogram.Keogram.set_magnetic_latitudes" href="#pyaurorax.tools.classes.keogram.Keogram.set_magnetic_latitudes">set_magnetic_latitudes</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
